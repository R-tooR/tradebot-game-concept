@startuml
'https://plantuml.com/class-diagram

'abstract class AbstractList
'abstract AbstractCollection
'interface List
'interface Collection
'
'List <|-- AbstractList
'Collection <|-- AbstractCollection
'
'Collection <|- List
'AbstractCollection <|- AbstractList
'AbstractList <|-- ArrayList
'
'class ArrayList {
'Object[] elementData
'size()
'}
'
'enum TimeUnit {
'DAYS
'HOURS
'MINUTES
'}

interface Technical {
  BigDecimal getRecentCandleFor(String pairName, Frequency freq)
  Optional<List<EntryValue>> getCandleBuffer(int size, Frequency freq, String pairName)
  boolean start()
  boolean stop()
}

Technical <|-- TechnicalImpl

class TechnicalImpl {
- Set<Scrapper> scrappers
- Map<String, Queue<EntryValue>> pairs

'rozważ zrobienie czegoś w stylu time-series DB - warto rozważyć np. InfluxDB
+ TechnicalImpl(Set<String> pairsToFollow)
+ boolean addPair(String newPair)
+ boolean addPairs(List<String> newPairs)
+ boolean detachPair(String newPair)
+ boolean detachPairs(List<String> newPairs)
' żeby nie kisić nadmiaru danych w pamięci JVM, można ich nadmiar wyrzucić do bazy danych
' jest javowy klient InfluxDB który pozwlala na zapisywanie do bazy okresowo
- flushRedundantDataToDB()
- updateValues(Set<Entry> entries)

}

class Entry {
    long timestamp
    EntryValue value
}

class EntryValue {
    String pairName
    BigDecimal value
}

TechnicalImpl *- Scrapper
TechnicalImpl <-- EntryValue
Entry -> TechnicalImpl
Scrapper <-- Client
note left
Client compliant with JAX-RS specification
end note

abstract class Scrapper {
    - ThreadPoolExecutor threadsPool
    - Set<Client> clientsPool

    - Map<String, BigDecimal> getCurrentPrices()
}

class GoogleScrapper extends Scrapper {
}
@enduml